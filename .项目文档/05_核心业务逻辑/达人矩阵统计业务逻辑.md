# 达人矩阵统计业务逻辑

## 概述

本文档详细描述达人矩阵属性分析功能的核心业务逻辑，包括分层统计、去重计算、占比计算、总计行计算等。

---

## 1. 数据准备

### 1.1 数据来源

统计数据来源于报告关联的笔记数据：

1. **报告笔记关联表（qiangua_report_note_rel）**：
   - 获取当前报告的所有笔记ID
   - 仅统计状态为 `active` 的笔记记录

2. **笔记数据表（qiangua_note_info）**：
   - 关联获取笔记详细信息和达人信息
   - 关键字段：
     - `BloggerId`: 达人ID（用于去重）
     - `Fans`: 达人粉丝数（用于分层）
     - `OfficialVerified`: 达人是否官方认证（用于知名KOL层）
     - `LikedCount`: 点赞数
     - `CollectedCount`: 收藏数
     - `CommentsCount`: 评论数
     - `ShareCount`: 分享数

### 1.2 数据筛选SQL

```sql
SELECT 
    n."BloggerId",
    n."Fans",
    n."OfficialVerified",
    n."LikedCount",
    n."CollectedCount",
    n."CommentsCount",
    n."ShareCount"
FROM qiangua_report_note_rel rn
INNER JOIN qiangua_note_info n ON rn."NoteId" = n."NoteId"
WHERE rn."ReportId" = $1
    AND rn."Status" = 'active';
```

---

## 2. 达人分层逻辑

### 2.1 知名KOL层

**筛选条件**：
- `OfficialVerified = true`

**优先级**：
- 知名KOL层优先级最高
- 如果达人是官方认证的，无论粉丝数多少，都计入知名KOL层
- 知名KOL层的达人不会出现在其他自定义层级中

**实现逻辑**：
```typescript
// 伪代码
const kolBloggers = notes
  .filter(note => note.OfficialVerified === true)
  .map(note => note.BloggerId);
```

### 2.2 自定义层级

**筛选条件**：
- 根据配置的粉丝数范围筛选
- 排除已在知名KOL层的达人

**范围匹配规则**：
- 如果 `maxFans` 为 `null`，表示无上限：`Fans >= minFans`
- 如果 `maxFans` 不为 `null`，表示有范围：`Fans >= minFans AND Fans < maxFans`
- 注意：范围是左闭右开区间 `[minFans, maxFans)`

**实现逻辑**：
```typescript
// 伪代码
const customLevelBloggers = customLevels.map(level => {
  const bloggers = notes
    .filter(note => {
      // 排除知名KOL
      if (note.OfficialVerified === true) return false;
      
      // 匹配粉丝数范围
      if (level.maxFans === null) {
        return note.Fans >= level.minFans;
      } else {
        return note.Fans >= level.minFans && note.Fans < level.maxFans;
      }
    })
    .map(note => note.BloggerId);
  
  return {
    levelId: level.levelId,
    levelName: level.levelName,
    bloggers: [...new Set(bloggers)] // 去重
  };
});
```

### 2.3 层级匹配优先级

1. **知名KOL层**：优先级最高，先匹配
2. **自定义层级**：按配置顺序匹配，第一个匹配的层级
3. **未匹配达人**：粉丝数不在任何层级范围内的达人，不计入任何层级（但会计入总计行）

---

## 3. 指标计算逻辑

### 3.1 达人数量计算

**计算方式**：
- 统计该层级中不重复的达人数量
- 按 `BloggerId` 去重

**实现逻辑**：
```typescript
// 伪代码
const bloggerCount = new Set(
  levelBloggers.map(blogger => blogger.BloggerId)
).size;
```

### 3.2 达人占比计算

**计算公式**：
```
达人占比 = (该层级达人数量 / 所有层级达人总数) × 100%
```

**所有层级达人总数**：
- 统计报告所有有效笔记对应的不重复达人总数（按 `BloggerId` 去重）
- 包含所有层级的达人，以及未匹配到任何层级的达人

**实现逻辑**：
```typescript
// 伪代码
const totalBloggers = new Set(
  notes.map(note => note.BloggerId)
).size;

const bloggerPercentage = (levelBloggerCount / totalBloggers) * 100;
```

### 3.3 平均粉丝数计算

**计算方式**：
- 该层级所有达人的粉丝数总和 / 该层级达人数量
- 需要先按达人去重，再计算平均值（避免同一达人的多条笔记影响平均值）

**实现逻辑**：
```typescript
// 伪代码
const uniqueBloggers = new Map();
levelBloggers.forEach(blogger => {
  if (!uniqueBloggers.has(blogger.BloggerId)) {
    uniqueBloggers.set(blogger.BloggerId, blogger.Fans);
  }
});

const totalFans = Array.from(uniqueBloggers.values()).reduce((sum, fans) => sum + fans, 0);
const avgFans = totalFans / uniqueBloggers.size;
```

### 3.4 总互动量计算

**计算方式**：
- 该层级所有笔记的互动量总和
- 互动量 = 点赞数 + 收藏数 + 评论数 + 分享数
- 不去重，统计所有笔记记录（因为同一达人的多条笔记都应计入）

**实现逻辑**：
```typescript
// 伪代码
const totalInteraction = levelNotes.reduce((sum, note) => {
  return sum + note.LikedCount + note.CollectedCount + note.CommentsCount + note.ShareCount;
}, 0);
```

### 3.5 互动量占比计算

**计算公式**：
```
互动量占比 = (该层级总互动量 / 所有层级总互动量) × 100%
```

**所有层级总互动量**：
- 报告所有有效笔记的互动量总和（所有active笔记的互动量之和）

**实现逻辑**：
```typescript
// 伪代码
const totalInteraction = notes.reduce((sum, note) => {
  return sum + note.LikedCount + note.CollectedCount + note.CommentsCount + note.ShareCount;
}, 0);

const interactionPercentage = (levelInteraction / totalInteraction) * 100;
```

### 3.6 笔记数量计算

**计算方式**：
- 该层级达人的笔记总数
- 不去重，统计所有笔记记录（因为同一达人的多条笔记都应计入）

**实现逻辑**：
```typescript
// 伪代码
const noteCount = levelNotes.length;
```

### 3.7 笔记占比计算

**计算公式**：
```
笔记占比 = (该层级笔记数量 / 所有层级笔记总数) × 100%
```

**所有层级笔记总数**：
- 报告所有有效笔记的总数（所有active笔记的数量）

**实现逻辑**：
```typescript
// 伪代码
const totalNotes = notes.length;
const notePercentage = (levelNoteCount / totalNotes) * 100;
```

---

## 4. 总计行计算逻辑

### 4.1 总计行说明

总计行统计的是报告中的所有有效笔记（状态为 `active` 的笔记），而不是表格中各层级数据的简单相加。

**原因**：
- 粉丝数过少的达人可能不在任何自定义层级范围内，且不是知名KOL
- 这些达人的笔记不会出现在表格的任何层级中
- 但应该计入总计行，以反映报告的真实数据

### 4.2 总计行指标计算

#### 4.2.1 层级名称
- 显示"总计"

#### 4.2.2 粉丝数范围
- 显示报告所有有效笔记对应的不重复达人中，粉丝数的最小值和最大值
- 格式：`最小值 - 最大值`（例如：`0.5万 - 120万`）
- 需要格式化显示（≥1万显示为"X.X万"）

**实现逻辑**：
```typescript
// 伪代码
const uniqueBloggers = new Set(notes.map(note => ({
  bloggerId: note.BloggerId,
  fans: note.Fans
})));

const fansArray = Array.from(uniqueBloggers).map(b => b.fans);
const minFans = Math.min(...fansArray);
const maxFans = Math.max(...fansArray);

const fansRange = `${formatFans(minFans)} - ${formatFans(maxFans)}`;
```

#### 4.2.3 达人数量
- 报告所有有效笔记对应的不重复达人总数（按 `BloggerId` 去重）

#### 4.2.4 达人占比
- 100.0%（固定值）

#### 4.2.5 平均粉丝数
- 报告所有有效笔记对应的不重复达人的平均粉丝数（按达人去重后计算平均值）

#### 4.2.6 总互动量
- 报告所有有效笔记的互动量总和（所有active笔记的互动量之和）

#### 4.2.7 互动量占比
- 100.0%（固定值）

#### 4.2.8 笔记数量
- 报告所有有效笔记的总数（所有active笔记的数量）

#### 4.2.9 笔记占比
- 100.0%（固定值）

---

## 5. 数据去重说明

### 5.1 达人数量去重

**规则**：
- 按 `BloggerId` 去重
- 确保每个达人只计算一次

**场景**：
- 同一达人在报告中有多条笔记
- 在统计达人数量时，只计算一次

### 5.2 平均粉丝数去重

**规则**：
- 先按达人去重，再计算平均值
- 避免同一达人的多条笔记影响平均值

**场景**：
- 同一达人在报告中有多条笔记
- 在计算平均粉丝数时，只使用该达人的一次粉丝数数据

### 5.3 笔记数量和互动量不去重

**规则**：
- 不去重，统计所有笔记记录
- 因为同一达人的多条笔记都应计入

**原因**：
- 笔记数量和互动量反映的是笔记维度的数据
- 同一达人的多条笔记都应该计入统计

---

## 6. 配置验证逻辑

### 6.1 层级名称验证

**规则**：
1. 不能为空
2. 长度：1-20个字符
3. 不能与现有层级名称重复（知名KOL除外）

**实现逻辑**：
```typescript
// 伪代码
function validateLevelName(levelName: string, existingNames: string[]): string | null {
  if (!levelName || levelName.trim().length === 0) {
    return '层级名称不能为空';
  }
  if (levelName.length > 20) {
    return '层级名称不能超过20个字符';
  }
  if (existingNames.includes(levelName)) {
    return '层级名称已存在，请使用其他名称';
  }
  return null;
}
```

### 6.2 粉丝数范围验证

**规则**：
1. `minFans` 必须 ≥ 0
2. 如果设置了 `maxFans`，必须 > `minFans`
3. 范围不能与其他层级重叠
4. 所有层级的范围必须连续覆盖（不能留空）

**实现逻辑**：
```typescript
// 伪代码
function validateFansRange(
  minFans: number,
  maxFans: number | null,
  existingRanges: Array<{ min: number; max: number | null }>
): string | null {
  if (minFans < 0) {
    return '最小粉丝数不能小于0';
  }
  if (maxFans !== null && maxFans <= minFans) {
    return '最大值必须大于最小值';
  }
  
  // 检查范围重叠
  for (const range of existingRanges) {
    if (rangesOverlap(minFans, maxFans, range.min, range.max)) {
      return '粉丝数范围与其他层级重叠，请调整';
    }
  }
  
  return null;
}

function rangesOverlap(
  min1: number,
  max1: number | null,
  min2: number,
  max2: number | null
): boolean {
  if (max1 === null && max2 === null) {
    return true; // 两个都是无上限，重叠
  }
  if (max1 === null) {
    return min1 <= max2!; // 第一个无上限
  }
  if (max2 === null) {
    return min2 <= max1; // 第二个无上限
  }
  return !(max1 <= min2 || max2 <= min1); // 有重叠
}
```

### 6.3 范围连续性验证

**规则**：
- 所有层级的范围必须连续覆盖（不能留空）
- 从0开始，到最大值（或无穷大）结束

**实现逻辑**：
```typescript
// 伪代码
function validateRangeContinuity(
  levels: Array<{ minFans: number; maxFans: number | null }>
): string | null {
  // 按 minFans 排序
  const sortedLevels = [...levels].sort((a, b) => a.minFans - b.minFans);
  
  // 检查是否从0开始
  if (sortedLevels[0].minFans !== 0) {
    return '层级之间不能留空，请确保所有粉丝数范围连续覆盖';
  }
  
  // 检查连续性
  for (let i = 0; i < sortedLevels.length - 1; i++) {
    const current = sortedLevels[i];
    const next = sortedLevels[i + 1];
    
    if (current.maxFans === null) {
      return '不能有多个无上限的层级';
    }
    
    if (current.maxFans !== next.minFans) {
      return '层级之间不能留空，请确保所有粉丝数范围连续覆盖';
    }
  }
  
  return null;
}
```

---

## 7. 默认配置

### 7.1 系统默认配置

如果数据库中不存在用户自定义配置，使用系统默认配置：

```typescript
const DEFAULT_CONFIG = {
  customLevels: [
    {
      levelName: '头部达人',
      minFans: 500000, // 50万
      maxFans: null // 无上限
    },
    {
      levelName: '腰部达人',
      minFans: 100000, // 10万
      maxFans: 500000 // 50万
    },
    {
      levelName: '初级达人',
      minFans: 10000, // 1万
      maxFans: 100000 // 10万
    },
    {
      levelName: '新手达人',
      minFans: 0,
      maxFans: 10000 // 1万
    }
  ]
};
```

### 7.2 知名KOL层

知名KOL层是固定层级，不在配置中，但在统计时始终存在：
- 层级名称：固定为"知名KOL"
- 筛选条件：`OfficialVerified = true`
- 不可编辑、不可删除

### 7.3 配置存储位置

自定义层级配置按报告维度存储在 `qiangua_report.CustomLevels` 字段（JSON）中：
- 读取：统计接口优先读取 `qiangua_report.CustomLevels`，为空则使用系统默认配置
- 保存：配置接口将用户自定义的 `customLevels` 更新到 `qiangua_report.CustomLevels`
- 删除：配置接口将 `qiangua_report.CustomLevels` 置为 `null`，前端回退到系统默认配置

---

## 8. 性能优化

### 8.1 前端计算优化

1. **数据缓存**：
   - 笔记数据缓存，避免重复请求
   - 配置数据缓存，避免重复加载

2. **计算优化**：
   - 使用 Map 和 Set 数据结构提高查找效率
   - 批量处理，避免多次遍历

3. **Web Worker**：
   - 如果笔记数量很大（>5000条），考虑使用 Web Worker 进行计算
   - 避免阻塞主线程

### 8.2 后端查询优化

1. **索引优化**：
   - `qiangua_report_note_rel` 表的 `(ReportId, Status)` 复合索引
   - `qiangua_note_info` 表的 `BloggerId` 索引

2. **查询优化**：
   - 只查询必要的字段
   - 使用 JOIN 而不是多次查询

---

## 9. 错误处理

### 9.1 数据异常

- **笔记数据缺失**：显示空状态提示
- **达人信息缺失**：跳过该笔记，不影响其他统计
- **配置数据异常**：使用系统默认配置

### 9.2 计算异常

- **除零错误**：占比显示为0%
- **数据溢出**：使用科学计数法或显示"超出范围"
- **计算超时**：显示加载状态，提示用户稍后重试

### 9.3 配置异常

- **配置格式错误**：使用系统默认配置
- **配置验证失败**：显示错误提示，不允许保存
- **保存失败**：显示错误提示，保留当前编辑状态

---

## 10. 注意事项

1. **数据一致性**：所有计算基于同一份笔记数据，确保数据一致性
2. **去重处理**：达人数量统计时按 `BloggerId` 去重，笔记数量和互动量不去重
3. **优先级处理**：知名KOL层优先级最高，先匹配知名KOL，再匹配自定义层级
4. **总计行计算**：总计行统计的是报告中的所有有效笔记，不是各层级数据的简单相加
5. **配置验证**：保存配置前必须通过所有验证规则
6. **性能考虑**：大量数据操作时使用分批处理或 Web Worker

