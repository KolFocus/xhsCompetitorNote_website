# 报告功能表设计

## 概述

报告功能需要两个核心表来存储报告信息和报告与笔记的关联关系：
- `reports` 表：存储报告基本信息
- `report_notes` 表：存储报告与笔记的关联关系（多对多），包含笔记状态

---

## 表结构设计

### 表1：reports（报告表）

存储用户创建的报告基本信息。

#### 字段说明

| 字段名 | 类型 | 说明 | 约束 | 索引 |
|--------|------|------|------|------|
| ReportId | UUID | 报告ID（主键） | PRIMARY KEY, NOT NULL, DEFAULT uuid_generate_v4() | PRIMARY KEY |
| UserId | UUID | 用户ID（外键，关联 auth.users） | NOT NULL, REFERENCES auth.users(id) | INDEX |
| ReportName | VARCHAR(200) | 报告名称 | NOT NULL | INDEX |
| CreatedAt | TIMESTAMPTZ | 创建时间（带时区） | NOT NULL, DEFAULT NOW() | INDEX |
| UpdatedAt | TIMESTAMPTZ | 更新时间（自动更新，带时区） | DEFAULT NOW() | |

#### 索引设计

- **主键索引**: `ReportId`
- **单列索引**: 
  - `UserId` - 按用户查询报告
  - `ReportName` - 按报告名称查询
  - `CreatedAt` - 按创建时间排序

#### 约束条件

- `ReportId` 主键，唯一
- `UserId` 不能为空，外键关联 `auth.users.id`
- `ReportName` 不能为空，8-20个字符（由应用层验证）
- `CreatedAt` 不能为空，默认当前时间

---

### 表2：report_notes（报告笔记关联表）

存储报告与笔记的关联关系，支持多对多关系，并记录笔记在报告中的状态。

#### 字段说明

| 字段名 | 类型 | 说明 | 约束 | 索引 |
|--------|------|------|------|------|
| ReportNoteId | UUID | 关联ID（主键） | PRIMARY KEY, NOT NULL, DEFAULT uuid_generate_v4() | PRIMARY KEY |
| ReportId | UUID | 报告ID（外键） | NOT NULL, REFERENCES reports(ReportId) ON DELETE CASCADE | INDEX |
| NoteId | VARCHAR(64) | 笔记ID（外键） | NOT NULL, REFERENCES qiangua_note_info(NoteId) | INDEX |
| Status | VARCHAR(20) | 笔记状态 | NOT NULL, DEFAULT 'active' | INDEX |
| CreatedAt | TIMESTAMPTZ | 创建时间（带时区） | NOT NULL, DEFAULT NOW() | INDEX |
| UpdatedAt | TIMESTAMPTZ | 更新时间（自动更新，带时区） | DEFAULT NOW() | |

#### 状态值说明

- `active`: 有效笔记（默认状态，参与分析）
- `ignored`: 已忽略笔记（不参与分析，但保留在报告中）
- `deleted`: 已删除笔记（逻辑删除，实际已从报告中移除）

**注意**: 删除操作实际上是物理删除记录，`deleted` 状态主要用于审计日志或恢复功能（如果未来需要）。

#### 索引设计

- **主键索引**: `ReportNoteId`
- **单列索引**: 
  - `ReportId` - 按报告查询笔记
  - `NoteId` - 按笔记查询报告
  - `Status` - 按状态筛选
  - `CreatedAt` - 按创建时间排序
- **复合索引**:
  - `(ReportId, Status)` - 按报告和状态查询（常用组合）
  - `(ReportId, NoteId)` - 唯一约束，防止重复添加同一笔记到同一报告
  - `(ReportId, CreatedAt)` - 按报告和时间查询

#### 约束条件

- `ReportNoteId` 主键，唯一
- `ReportId` 不能为空，外键关联 `reports.ReportId`，级联删除
- `NoteId` 不能为空，外键关联 `qiangua_note_info.NoteId`
- `Status` 不能为空，默认值为 `'active'`
- **唯一约束**: `(ReportId, NoteId)` - 同一笔记不能重复添加到同一报告中（无论状态如何）

---

## 表关系说明

### reports 与 auth.users 的关系

- **关系类型**: 多对一（Many-to-One）
- **实现方式**: 通过 `reports.UserId` 外键关联到 `auth.users.id`
- **关系说明**: 
  - 一个用户可以创建多个报告
  - 每个报告只能属于一个用户
  - 通过外键约束保证数据一致性

### reports 与 qiangua_note_info 的关系

- **关系类型**: 多对多（Many-to-Many）
- **实现方式**: 通过 `report_notes` 中间表关联
- **关系说明**: 
  - 一个报告可以包含多条笔记
  - 一条笔记可以属于多个报告（虽然业务上可能不常见，但数据结构支持）
  - 通过 `report_notes` 表记录关联关系和状态

### report_notes 与 reports 的关系

- **关系类型**: 多对一（Many-to-One）
- **实现方式**: 通过 `report_notes.ReportId` 外键关联到 `reports.ReportId`
- **级联删除**: 当报告被删除时，自动删除所有关联的 `report_notes` 记录

### report_notes 与 qiangua_note_info 的关系

- **关系类型**: 多对一（Many-to-One）
- **实现方式**: 通过 `report_notes.NoteId` 外键关联到 `qiangua_note_info.NoteId`
- **关系说明**: 
  - 一条笔记可以在多个报告中出现
  - 通过 `(ReportId, NoteId)` 唯一约束防止重复添加

---

## 创建表SQL

### 1. 创建 reports 表

```sql
-- 创建 reports 表
CREATE TABLE IF NOT EXISTS reports (
    "ReportId" UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "UserId" UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    "ReportName" VARCHAR(200) NOT NULL,
    "CreatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "UpdatedAt" TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_reports_user_id ON reports("UserId");
CREATE INDEX idx_reports_report_name ON reports("ReportName");
CREATE INDEX idx_reports_created_at ON reports("CreatedAt");

-- 创建更新时间触发器函数（如果不存在）
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW."UpdatedAt" = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- 创建更新时间触发器
CREATE TRIGGER update_reports_updated_at 
    BEFORE UPDATE ON reports
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### 2. 创建 report_notes 表

```sql
-- 创建 report_notes 表
CREATE TABLE IF NOT EXISTS report_notes (
    "ReportNoteId" UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "ReportId" UUID NOT NULL REFERENCES reports("ReportId") ON DELETE CASCADE,
    "NoteId" VARCHAR(64) NOT NULL REFERENCES qiangua_note_info("NoteId") ON DELETE CASCADE,
    "Status" VARCHAR(20) NOT NULL DEFAULT 'active',
    "CreatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "UpdatedAt" TIMESTAMPTZ DEFAULT NOW(),
    -- 唯一约束：同一笔记不能重复添加到同一报告中
    UNIQUE("ReportId", "NoteId")
);

-- 创建索引
CREATE INDEX idx_report_notes_report_id ON report_notes("ReportId");
CREATE INDEX idx_report_notes_note_id ON report_notes("NoteId");
CREATE INDEX idx_report_notes_status ON report_notes("Status");
CREATE INDEX idx_report_notes_created_at ON report_notes("CreatedAt");

-- 复合索引
CREATE INDEX idx_report_notes_report_status ON report_notes("ReportId", "Status");
CREATE INDEX idx_report_notes_report_created_at ON report_notes("ReportId", "CreatedAt");

-- 创建更新时间触发器
CREATE TRIGGER update_report_notes_updated_at 
    BEFORE UPDATE ON report_notes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### 3. 创建状态枚举类型（可选，PostgreSQL 推荐方式）

如果需要更严格的类型约束，可以使用 ENUM 类型：

```sql
-- 创建状态枚举类型
CREATE TYPE report_note_status AS ENUM ('active', 'ignored', 'deleted');

-- 修改 report_notes 表的 Status 字段类型
ALTER TABLE report_notes 
    ALTER COLUMN "Status" TYPE report_note_status 
    USING "Status"::report_note_status;

-- 设置默认值
ALTER TABLE report_notes 
    ALTER COLUMN "Status" SET DEFAULT 'active';
```

---

## RLS（行级安全）策略

### reports 表

```sql
-- 启用RLS
ALTER TABLE reports ENABLE ROW LEVEL SECURITY;

-- 策略：用户只能查看、创建、更新、删除自己的报告
CREATE POLICY "Users can view their own reports"
    ON reports
    FOR SELECT
    USING (auth.uid() = "UserId");

CREATE POLICY "Users can create their own reports"
    ON reports
    FOR INSERT
    WITH CHECK (auth.uid() = "UserId");

CREATE POLICY "Users can update their own reports"
    ON reports
    FOR UPDATE
    USING (auth.uid() = "UserId")
    WITH CHECK (auth.uid() = "UserId");

CREATE POLICY "Users can delete their own reports"
    ON reports
    FOR DELETE
    USING (auth.uid() = "UserId");
```

### report_notes 表

```sql
-- 启用RLS
ALTER TABLE report_notes ENABLE ROW LEVEL SECURITY;

-- 策略：用户只能操作自己报告中的笔记
CREATE POLICY "Users can view notes in their reports"
    ON report_notes
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM reports 
            WHERE reports."ReportId" = report_notes."ReportId" 
            AND reports."UserId" = auth.uid()
        )
    );

CREATE POLICY "Users can add notes to their reports"
    ON report_notes
    FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM reports 
            WHERE reports."ReportId" = report_notes."ReportId" 
            AND reports."UserId" = auth.uid()
        )
    );

CREATE POLICY "Users can update notes in their reports"
    ON report_notes
    FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM reports 
            WHERE reports."ReportId" = report_notes."ReportId" 
            AND reports."UserId" = auth.uid()
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM reports 
            WHERE reports."ReportId" = report_notes."ReportId" 
            AND reports."UserId" = auth.uid()
        )
    );

CREATE POLICY "Users can delete notes from their reports"
    ON report_notes
    FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM reports 
            WHERE reports."ReportId" = report_notes."ReportId" 
            AND reports."UserId" = auth.uid()
        )
    );
```

---

## 查询优化建议

### 1. 获取报告列表（按用户）

```sql
-- 获取用户的所有报告（按创建时间倒序）
SELECT 
    "ReportId",
    "ReportName",
    "CreatedAt",
    "UpdatedAt"
FROM reports
WHERE "UserId" = $1
ORDER BY "CreatedAt" DESC;
```

### 2. 获取报告详情（包含统计信息）

```sql
-- 获取报告基本信息
SELECT 
    r."ReportId",
    r."ReportName",
    r."CreatedAt",
    r."UpdatedAt",
    -- 有效笔记数
    COUNT(CASE WHEN rn."Status" = 'active' THEN 1 END) as active_notes_count,
    -- 已忽略笔记数
    COUNT(CASE WHEN rn."Status" = 'ignored' THEN 1 END) as ignored_notes_count,
    -- 最早笔记时间
    MIN(n."PublishTime") as earliest_note_time,
    -- 最晚笔记时间
    MAX(n."PublishTime") as latest_note_time
FROM reports r
LEFT JOIN report_notes rn ON r."ReportId" = rn."ReportId"
LEFT JOIN qiangua_note_info n ON rn."NoteId" = n."NoteId"
WHERE r."ReportId" = $1
GROUP BY r."ReportId", r."ReportName", r."CreatedAt", r."UpdatedAt";
```

### 3. 获取报告中的笔记列表（带筛选和分页）

```sql
-- 获取报告中的笔记列表（有效笔记）
SELECT 
    n.*,
    rn."Status",
    rn."CreatedAt" as added_at
FROM report_notes rn
INNER JOIN qiangua_note_info n ON rn."NoteId" = n."NoteId"
WHERE rn."ReportId" = $1
    AND rn."Status" = 'active'
    -- 可选：品牌筛选
    AND ($2::VARCHAR IS NULL OR n."BrandId" = $2)
    -- 可选：博主筛选
    AND ($3::VARCHAR IS NULL OR n."BloggerId" = $3)
    -- 可选：时间范围筛选
    AND ($4::DATE IS NULL OR n."PubDate" >= $4)
    AND ($5::DATE IS NULL OR n."PubDate" <= $5)
ORDER BY n."PublishTime" DESC
LIMIT $6 OFFSET $7;
```

### 4. 计算符合条件的笔记数量（创建报告时）

```sql
-- 计算符合条件的笔记数量
SELECT COUNT(*) as total_count
FROM qiangua_note_info
WHERE 
    -- 品牌筛选（多选）
    ($1::VARCHAR[] IS NULL OR "BrandId" = ANY($1::VARCHAR[]))
    -- 时间范围筛选
    AND ($2::DATE IS NULL OR "PubDate" >= $2)
    AND ($3::DATE IS NULL OR "PubDate" <= $3);
```

### 5. 计算增量笔记数量（追加笔记时）

```sql
-- 计算符合条件且不在报告中的笔记数量
SELECT COUNT(*) as new_count
FROM qiangua_note_info n
WHERE 
    -- 品牌筛选（多选）
    ($1::VARCHAR[] IS NULL OR n."BrandId" = ANY($1::VARCHAR[]))
    -- 时间范围筛选
    AND ($2::DATE IS NULL OR n."PubDate" >= $2)
    AND ($3::DATE IS NULL OR n."PubDate" <= $3)
    -- 排除已在报告中的笔记（无论状态如何）
    AND NOT EXISTS (
        SELECT 1 FROM report_notes rn
        WHERE rn."ReportId" = $4
        AND rn."NoteId" = n."NoteId"
    );
```

### 6. 获取报告内所有品牌列表

```sql
-- 获取报告内所有笔记涉及的品牌集合
SELECT DISTINCT n."BrandId", n."BrandName"
FROM report_notes rn
INNER JOIN qiangua_note_info n ON rn."NoteId" = n."NoteId"
WHERE rn."ReportId" = $1
    AND n."BrandId" IS NOT NULL
ORDER BY n."BrandName";
```

---

## 数据操作说明

### 创建报告

1. 插入 `reports` 表记录
2. 批量插入符合条件的笔记到 `report_notes` 表（状态为 `active`）

### 追加笔记

1. 查询符合条件的笔记（排除已在报告中的笔记）
2. 批量插入到 `report_notes` 表（状态为 `active`）
3. 使用 `ON CONFLICT` 处理重复（虽然理论上不应该重复）

### 忽略笔记

1. 更新 `report_notes` 表的 `Status` 字段为 `'ignored'`

### 删除笔记

1. 物理删除 `report_notes` 表中的记录（使用 `DELETE`）

### 恢复笔记

1. 更新 `report_notes` 表的 `Status` 字段为 `'active'`

---

## 注意事项

1. **唯一约束**: `(ReportId, NoteId)` 确保同一笔记不会重复添加到同一报告中
2. **级联删除**: 删除报告时，自动删除所有关联的 `report_notes` 记录
3. **状态管理**: 删除操作是物理删除，不是逻辑删除（如果需要审计，可以改为逻辑删除）
4. **性能优化**: 使用复合索引 `(ReportId, Status)` 优化常用查询
5. **RLS策略**: 确保用户只能操作自己的报告数据
6. **UUID生成**: 使用 PostgreSQL 的 `uuid_generate_v4()` 函数生成主键
7. **时间戳**: 使用 `TIMESTAMPTZ` 类型存储带时区的时间戳，便于处理不同时区

---

## 后续扩展建议

1. **报告模板**: 可以添加 `TemplateId` 字段支持报告模板
2. **报告共享**: 可以添加 `SharedWith` 字段支持报告共享
3. **报告标签**: 可以添加标签表支持报告分类
4. **审计日志**: 可以添加审计日志表记录报告操作历史
5. **报告版本**: 可以添加版本管理支持报告历史版本

