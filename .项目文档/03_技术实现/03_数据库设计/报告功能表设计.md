# 报告功能表设计

## 概述

报告功能需要两个核心表来存储报告信息和报告与笔记的关联关系：
- `qiangua_report` 表：存储报告基本信息
- `qiangua_report_note_rel` 表：存储报告与笔记的关联关系（多对多），包含笔记状态

---

## 表结构设计

### 表1：qiangua_report（报告表）

存储用户创建的报告基本信息。

#### 字段说明

| 字段名 | 类型 | 说明 | 约束 | 索引 |
|--------|------|------|------|------|
| ReportId | UUID | 报告ID（主键） | PRIMARY KEY, NOT NULL, DEFAULT uuid_generate_v4() | PRIMARY KEY |
| UserId | UUID | 用户ID（外键，关联 auth.users） | NOT NULL, REFERENCES auth.users(id) | INDEX |
| ReportName | VARCHAR(200) | 报告名称 | NOT NULL | INDEX |
| Status | VARCHAR(20) | 报告状态 | NOT NULL, DEFAULT 'active' | INDEX |
| CustomLevels | JSONB | 达人矩阵自定义层级配置（报告维度） | NULL |  |
| CreatedAt | TIMESTAMPTZ | 创建时间（带时区） | NOT NULL, DEFAULT NOW() | INDEX |
| UpdatedAt | TIMESTAMPTZ | 更新时间（自动更新，带时区） | DEFAULT NOW() | |

#### 状态值说明

- `active`: 有效报告（默认状态，正常显示和使用）
- `hide`: 已隐藏报告（逻辑删除，不显示但保留数据）

**注意**: 删除操作是逻辑删除，通过更新 `Status` 字段为 `'hide'` 实现，不会物理删除记录。
**重要**: 使用 `'hide'` 而不是 `'delete'`，避免SQL保留关键字冲突。

#### 配置存储说明

- 自定义层级配置字段：`qiangua_report.CustomLevels`（JSONB）
- 读取优先级：统计接口优先读取 `CustomLevels`；为空则使用系统默认配置
- 保存逻辑：配置接口更新 `CustomLevels`；重置时置为 `NULL`

#### 索引设计

- **主键索引**: `ReportId`
- **单列索引**: 
  - `UserId` - 按用户查询报告
  - `ReportName` - 按报告名称查询
  - `Status` - 按状态筛选
  - `CreatedAt` - 按创建时间排序
- **复合索引**:
  - `(UserId, Status)` - 按用户和状态查询（常用组合）

#### 约束条件

- `ReportId` 主键，唯一
- `UserId` 不能为空，外键关联 `auth.users.id`
- `ReportName` 不能为空，8-20个字符（由应用层验证）
- `Status` 不能为空，默认值为 `'active'`
- `CreatedAt` 不能为空，默认当前时间

---

### 表2：qiangua_report_note_rel（报告笔记关联表）

存储报告与笔记的关联关系，支持多对多关系，并记录笔记在报告中的状态。

#### 字段说明

| 字段名 | 类型 | 说明 | 约束 | 索引 |
|--------|------|------|------|------|
| ReportNoteId | UUID | 关联ID（主键） | PRIMARY KEY, NOT NULL, DEFAULT uuid_generate_v4() | PRIMARY KEY |
| ReportId | UUID | 报告ID（外键） | NOT NULL, REFERENCES qiangua_report(ReportId) ON DELETE CASCADE | INDEX |
| NoteId | VARCHAR(64) | 笔记ID（外键） | NOT NULL, REFERENCES qiangua_note_info(NoteId) | INDEX |
| Status | VARCHAR(20) | 笔记状态 | NOT NULL, DEFAULT 'active' | INDEX |
| CreatedAt | TIMESTAMPTZ | 创建时间（带时区） | NOT NULL, DEFAULT NOW() | INDEX |
| UpdatedAt | TIMESTAMPTZ | 更新时间（自动更新，带时区） | DEFAULT NOW() | |

#### 状态值说明

- `active`: 有效笔记（默认状态，参与分析）
- `ignored`: 已忽略笔记（不参与分析，但保留在报告中）

**注意**: 删除操作是物理删除记录，直接从 `qiangua_report_note_rel` 表中移除记录。

#### 索引设计

- **主键索引**: `ReportNoteId`
- **单列索引**: 
  - `ReportId` - 按报告查询笔记
  - `NoteId` - 按笔记查询报告
  - `Status` - 按状态筛选
  - `CreatedAt` - 按创建时间排序
- **复合索引**:
  - `(ReportId, Status)` - 按报告和状态查询（常用组合）
  - `(ReportId, NoteId)` - 唯一约束，防止重复添加同一笔记到同一报告
  - `(ReportId, CreatedAt)` - 按报告和时间查询

#### 约束条件

- `ReportNoteId` 主键，唯一
- `ReportId` 不能为空，外键关联 `qiangua_report.ReportId`，级联删除
- `NoteId` 不能为空，外键关联 `qiangua_note_info.NoteId`
- `Status` 不能为空，默认值为 `'active'`
- **唯一约束**: `(ReportId, NoteId)` - 同一笔记不能重复添加到同一报告中（无论状态如何）

---

## 表关系说明

### qiangua_report 与 auth.users 的关系

- **关系类型**: 多对一（Many-to-One）
- **实现方式**: 通过 `qiangua_report.UserId` 外键关联到 `auth.users.id`
- **关系说明**: 
  - 一个用户可以创建多个报告
  - 每个报告只能属于一个用户
  - 通过外键约束保证数据一致性

### qiangua_report 与 qiangua_note_info 的关系

- **关系类型**: 多对多（Many-to-Many）
- **实现方式**: 通过 `qiangua_report_note_rel` 中间表关联
- **关系说明**: 
  - 一个报告可以包含多条笔记
  - 一条笔记可以属于多个报告（虽然业务上可能不常见，但数据结构支持）
  - 通过 `qiangua_report_note_rel` 表记录关联关系和状态

### qiangua_report_note_rel 与 qiangua_report 的关系

- **关系类型**: 多对一（Many-to-One）
- **实现方式**: 通过 `qiangua_report_note_rel.ReportId` 外键关联到 `qiangua_report.ReportId`
- **级联删除**: 当报告被物理删除时，自动删除所有关联的 `qiangua_report_note_rel` 记录
- **逻辑删除**: 当报告状态为 `hide` 时，关联的笔记关系仍然保留

### qiangua_report_note_rel 与 qiangua_note_info 的关系

- **关系类型**: 多对一（Many-to-One）
- **实现方式**: 通过 `qiangua_report_note_rel.NoteId` 外键关联到 `qiangua_note_info.NoteId`
- **关系说明**: 
  - 一条笔记可以在多个报告中出现
  - 通过 `(ReportId, NoteId)` 唯一约束防止重复添加

---

## 创建表SQL

### 1. 创建 qiangua_report 表

```sql
-- 创建 qiangua_report 表
CREATE TABLE IF NOT EXISTS qiangua_report (
    "ReportId" UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "UserId" UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    "ReportName" VARCHAR(200) NOT NULL,
    "Status" VARCHAR(20) NOT NULL DEFAULT 'active',
    "CustomLevels" JSONB NULL,
    "CreatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "UpdatedAt" TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_qiangua_report_user_id ON qiangua_report("UserId");
CREATE INDEX idx_qiangua_report_report_name ON qiangua_report("ReportName");
CREATE INDEX idx_qiangua_report_status ON qiangua_report("Status");
CREATE INDEX idx_qiangua_report_created_at ON qiangua_report("CreatedAt");

-- 复合索引
CREATE INDEX idx_qiangua_report_user_status ON qiangua_report("UserId", "Status");

-- 创建更新时间触发器函数（如果不存在）
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW."UpdatedAt" = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- 创建更新时间触发器
CREATE TRIGGER update_qiangua_report_updated_at 
    BEFORE UPDATE ON qiangua_report
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### 2. 创建 qiangua_report_note_rel 表

```sql
-- 创建 qiangua_report_note_rel 表
CREATE TABLE IF NOT EXISTS qiangua_report_note_rel (
    "ReportNoteId" UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "ReportId" UUID NOT NULL REFERENCES qiangua_report("ReportId") ON DELETE CASCADE,
    "NoteId" VARCHAR(64) NOT NULL REFERENCES qiangua_note_info("NoteId") ON DELETE CASCADE,
    "Status" VARCHAR(20) NOT NULL DEFAULT 'active',
    "CreatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "UpdatedAt" TIMESTAMPTZ DEFAULT NOW(),
    -- 唯一约束：同一笔记不能重复添加到同一报告中
    UNIQUE("ReportId", "NoteId")
);

-- 创建索引
CREATE INDEX idx_qiangua_report_note_rel_report_id ON qiangua_report_note_rel("ReportId");
CREATE INDEX idx_qiangua_report_note_rel_note_id ON qiangua_report_note_rel("NoteId");
CREATE INDEX idx_qiangua_report_note_rel_status ON qiangua_report_note_rel("Status");
CREATE INDEX idx_qiangua_report_note_rel_created_at ON qiangua_report_note_rel("CreatedAt");

-- 复合索引
CREATE INDEX idx_qiangua_report_note_rel_report_status ON qiangua_report_note_rel("ReportId", "Status");
CREATE INDEX idx_qiangua_report_note_rel_report_created_at ON qiangua_report_note_rel("ReportId", "CreatedAt");

-- 创建更新时间触发器
CREATE TRIGGER update_qiangua_report_note_rel_updated_at 
    BEFORE UPDATE ON qiangua_report_note_rel
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### 3. 创建状态枚举类型（可选，PostgreSQL 推荐方式）

如果需要更严格的类型约束，可以使用 ENUM 类型：

```sql
-- 创建报告状态枚举类型
CREATE TYPE report_status AS ENUM ('active', 'hide');

-- 修改 qiangua_report 表的 Status 字段类型
ALTER TABLE qiangua_report 
    ALTER COLUMN "Status" TYPE report_status 
    USING "Status"::report_status;

-- 设置默认值
ALTER TABLE qiangua_report 
    ALTER COLUMN "Status" SET DEFAULT 'active';

-- 创建笔记状态枚举类型
CREATE TYPE report_note_status AS ENUM ('active', 'ignored');

-- 修改 qiangua_report_note_rel 表的 Status 字段类型
ALTER TABLE qiangua_report_note_rel 
    ALTER COLUMN "Status" TYPE report_note_status 
    USING "Status"::report_note_status;

-- 设置默认值
ALTER TABLE qiangua_report_note_rel 
    ALTER COLUMN "Status" SET DEFAULT 'active';
```

---

## RLS（行级安全）策略

### qiangua_report 表

```sql
-- 启用RLS
ALTER TABLE qiangua_report ENABLE ROW LEVEL SECURITY;

-- 策略：用户只能查看、创建、更新、删除自己的报告
CREATE POLICY "Users can view their own reports"
    ON qiangua_report
    FOR SELECT
    USING (auth.uid() = "UserId" AND "Status" = 'active');

CREATE POLICY "Users can create their own reports"
    ON qiangua_report
    FOR INSERT
    WITH CHECK (auth.uid() = "UserId");

CREATE POLICY "Users can update their own reports"
    ON qiangua_report
    FOR UPDATE
    USING (auth.uid() = "UserId")
    WITH CHECK (auth.uid() = "UserId");

CREATE POLICY "Users can delete their own reports"
    ON qiangua_report
    FOR DELETE
    USING (auth.uid() = "UserId");

-- 注意：实际应用中，删除操作应该通过 UPDATE 将 Status 设置为 'hide' 实现逻辑删除
-- 物理删除操作应谨慎使用，建议仅管理员或特殊场景使用
-- 重要：使用 'hide' 而不是 'delete'，避免SQL保留关键字冲突
```

### qiangua_report_note_rel 表

```sql
-- 启用RLS
ALTER TABLE qiangua_report_note_rel ENABLE ROW LEVEL SECURITY;

-- 策略：用户只能操作自己报告中的笔记
CREATE POLICY "Users can view notes in their reports"
    ON qiangua_report_note_rel
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM qiangua_report 
            WHERE qiangua_report."ReportId" = qiangua_report_note_rel."ReportId" 
            AND qiangua_report."UserId" = auth.uid()
        )
    );

CREATE POLICY "Users can add notes to their reports"
    ON qiangua_report_note_rel
    FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM qiangua_report 
            WHERE qiangua_report."ReportId" = qiangua_report_note_rel."ReportId" 
            AND qiangua_report."UserId" = auth.uid()
        )
    );

CREATE POLICY "Users can update notes in their reports"
    ON qiangua_report_note_rel
    FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM qiangua_report 
            WHERE qiangua_report."ReportId" = qiangua_report_note_rel."ReportId" 
            AND qiangua_report."UserId" = auth.uid()
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM qiangua_report 
            WHERE qiangua_report."ReportId" = qiangua_report_note_rel."ReportId" 
            AND qiangua_report."UserId" = auth.uid()
        )
    );

CREATE POLICY "Users can delete notes from their reports"
    ON qiangua_report_note_rel
    FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM qiangua_report 
            WHERE qiangua_report."ReportId" = qiangua_report_note_rel."ReportId" 
            AND qiangua_report."UserId" = auth.uid()
        )
    );
```

---

## 查询优化建议

### 1. 获取报告列表（按用户）

```sql
-- 获取用户的所有有效报告（按创建时间倒序）
SELECT 
    "ReportId",
    "ReportName",
    "Status",
    "CreatedAt",
    "UpdatedAt"
FROM qiangua_report
WHERE "UserId" = $1
    AND "Status" = 'active'
ORDER BY "CreatedAt" DESC;
```

### 2. 获取报告详情（包含统计信息）

```sql
-- 获取报告基本信息（仅获取有效报告）
SELECT 
    r."ReportId",
    r."ReportName",
    r."Status",
    r."CreatedAt",
    r."UpdatedAt",
    -- 有效笔记数
    COUNT(CASE WHEN rn."Status" = 'active' THEN 1 END) as active_notes_count,
    -- 已忽略笔记数
    COUNT(CASE WHEN rn."Status" = 'ignored' THEN 1 END) as ignored_notes_count,
    -- 最早笔记时间
    MIN(n."PublishTime") as earliest_note_time,
    -- 最晚笔记时间
    MAX(n."PublishTime") as latest_note_time
FROM qiangua_report r
LEFT JOIN qiangua_report_note_rel rn ON r."ReportId" = rn."ReportId"
LEFT JOIN qiangua_note_info n ON rn."NoteId" = n."NoteId"
WHERE r."ReportId" = $1
    AND r."Status" = 'active'
GROUP BY r."ReportId", r."ReportName", r."Status", r."CreatedAt", r."UpdatedAt";
```

### 3. 获取报告中的笔记列表（带筛选和分页）

```sql
-- 获取报告中的笔记列表（有效笔记，仅查询有效报告）
SELECT 
    n.*,
    rn."Status",
    rn."CreatedAt" as added_at
FROM qiangua_report_note_rel rn
INNER JOIN qiangua_note_info n ON rn."NoteId" = n."NoteId"
INNER JOIN qiangua_report r ON rn."ReportId" = r."ReportId"
WHERE rn."ReportId" = $1
    AND r."Status" = 'active'
    AND rn."Status" = 'active'
    -- 可选：品牌筛选
    AND ($2::VARCHAR IS NULL OR n."BrandId" = $2)
    -- 可选：博主筛选
    AND ($3::VARCHAR IS NULL OR n."BloggerId" = $3)
    -- 可选：时间范围筛选
    AND ($4::DATE IS NULL OR n."PubDate" >= $4)
    AND ($5::DATE IS NULL OR n."PubDate" <= $5)
ORDER BY n."PublishTime" DESC
LIMIT $6 OFFSET $7;
```

### 4. 计算符合条件的笔记数量（创建报告时）

```sql
-- 计算符合条件的笔记数量
SELECT COUNT(*) as total_count
FROM qiangua_note_info
WHERE 
    -- 品牌筛选（多选）
    ($1::VARCHAR[] IS NULL OR "BrandId" = ANY($1::VARCHAR[]))
    -- 时间范围筛选
    AND ($2::DATE IS NULL OR "PubDate" >= $2)
    AND ($3::DATE IS NULL OR "PubDate" <= $3);
```

### 5. 计算增量笔记数量（追加笔记时）

```sql
-- 计算符合条件且不在报告中的笔记数量
SELECT COUNT(*) as new_count
FROM qiangua_note_info n
WHERE 
    -- 品牌筛选（多选）
    ($1::VARCHAR[] IS NULL OR n."BrandId" = ANY($1::VARCHAR[]))
    -- 时间范围筛选
    AND ($2::DATE IS NULL OR n."PubDate" >= $2)
    AND ($3::DATE IS NULL OR n."PubDate" <= $3)
    -- 排除已在报告中的笔记（无论状态如何）
    AND NOT EXISTS (
        SELECT 1 FROM qiangua_report_note_rel rn
        WHERE rn."ReportId" = $4
        AND rn."NoteId" = n."NoteId"
    );
```

### 6. 获取报告内所有品牌列表

```sql
-- 获取报告内所有笔记涉及的品牌集合（仅查询有效报告）
SELECT DISTINCT n."BrandId", n."BrandName"
FROM qiangua_report_note_rel rn
INNER JOIN qiangua_note_info n ON rn."NoteId" = n."NoteId"
INNER JOIN qiangua_report r ON rn."ReportId" = r."ReportId"
WHERE rn."ReportId" = $1
    AND r."Status" = 'active'
    AND n."BrandId" IS NOT NULL
ORDER BY n."BrandName";
```

---

## 数据操作说明

### 创建报告

1. 插入 `qiangua_report` 表记录（状态默认为 `active`）
2. 批量插入符合条件的笔记到 `qiangua_report_note_rel` 表（状态为 `active`）

### 追加笔记

1. 查询符合条件的笔记（排除已在报告中的笔记）
2. 批量插入到 `qiangua_report_note_rel` 表（状态为 `active`）
3. 使用 `ON CONFLICT` 处理重复（虽然理论上不应该重复）

### 忽略笔记

1. 更新 `qiangua_report_note_rel` 表的 `Status` 字段为 `'ignored'`

### 删除笔记

1. 物理删除 `qiangua_report_note_rel` 表中的记录（使用 `DELETE`）

### 恢复笔记

1. 更新 `qiangua_report_note_rel` 表的 `Status` 字段为 `'active'`

### 删除报告

1. 逻辑删除：更新 `qiangua_report` 表的 `Status` 字段为 `'hide'`（推荐方式）
2. 物理删除：直接删除 `qiangua_report` 表中的记录（会级联删除关联的 `qiangua_report_note_rel` 记录，谨慎使用）

### 恢复报告

1. 更新 `qiangua_report` 表的 `Status` 字段为 `'active'`

---

## 注意事项

1. **唯一约束**: `(ReportId, NoteId)` 确保同一笔记不会重复添加到同一报告中
2. **报告状态管理**: 报告删除采用逻辑删除，通过更新 `Status` 为 `'hide'` 实现，保留数据便于恢复和审计（使用'hide'避免SQL保留关键字冲突）
3. **笔记状态管理**: 笔记删除操作是物理删除，直接从 `qiangua_report_note_rel` 表中移除记录
4. **级联删除**: 物理删除报告时，自动删除所有关联的 `qiangua_report_note_rel` 记录（谨慎使用）
5. **性能优化**: 
   - 使用复合索引 `(UserId, Status)` 优化按用户查询有效报告
   - 使用复合索引 `(ReportId, Status)` 优化报告笔记查询
6. **RLS策略**: 确保用户只能操作自己的报告数据，查询时自动过滤 `delete` 状态的报告
7. **UUID生成**: 使用 PostgreSQL 的 `uuid_generate_v4()` 函数生成主键
8. **时间戳**: 使用 `TIMESTAMPTZ` 类型存储带时区的时间戳，便于处理不同时区

---

## 后续扩展建议

1. **报告模板**: 可以添加 `TemplateId` 字段支持报告模板
2. **报告共享**: 可以添加 `SharedWith` 字段支持报告共享
3. **报告标签**: 可以添加标签表支持报告分类
4. **审计日志**: 可以添加审计日志表记录报告操作历史
5. **报告版本**: 可以添加版本管理支持报告历史版本

