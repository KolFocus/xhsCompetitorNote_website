# 笔记标签化业务逻辑

> 参考文档：`达人矩阵统计业务逻辑.md` 风格。与 `笔记内容标签化功能规格.md` 对应，详细描述后端与数据层的业务规则。

## 1. 范围与目标
- 明确标签筛选、统计、去重的业务规则与边界。
- 为 API 设计、数据库实现与测试用例提供统一依据。
- 涵盖系统标签系列与用户自定义标签系列的差异化处理。

## 2. 数据对象定义
- **标签系列（Tag Set）**：`qiangua_tag_set` 表记录，可分为 `system`、`custom` 两种类型。
- **标签（Tag）**：`qiangua_tag` 表记录，隶属于一个标签系列。
- **笔记-标签关联（Note Tagging）**：`qiangua_note_tag` 表记录，仅保留最近一次操作的 `UserId` 与 `UpdatedAt`。
- **笔记（Note）**：`public.qiangua_note_info` 视图/表记录，主键字段 `NoteId`（`character varying`），另含 `BloggerId`, `BrandId`, `CreatedAt`, `ReportId` 等。

## 3. 标签筛选逻辑

### 3.1 基本规则
1. **标签系列约束**：所有筛选均在用户当前选择的 `TagSetId` 范围内执行；未选择标签系列时禁止发起筛选请求。
2. **权限过滤**：仅返回用户有权访问的笔记与标签。
   - 系统标签系列对所有认证用户可读。
   - 自定义标签系列仅对拥有者开放（见 RLS 策略）。
3. **未打标开关**：`未打标` 与 `标签单选` 互斥，前端默认勾选 `未打标`，后端若同时收到两种条件时，优先按 `未打标` 处理。

### 3.2 组合条件
- **单标签筛选**：请求参数 `tagId` 存在时，返回满足 `"NoteId"` 与该 `tagId` 关联关系的笔记。
- **未打标筛选**：请求参数 `unTagged=true` 时，使用 `NOT EXISTS` 约束排除已关联任意标签的笔记。
- **其他维度（品牌、博主、日期、报告）**：与标签条件做 `AND` 交集，确保分页、排序规则与现有笔记列表一致。
- **分页**：默认按笔记创建时间倒序，分页参数 `page`, `pageSize`；`pageSize` 最大 100。

### 3.3 缓存与刷新
- 标签列表与筛选结果允许使用 `Supabase Edge Functions` 或前端缓存 5 分钟。
- 当用户执行打标/清除操作时，必须强制失效当前 `TagSetId` 的缓存。

## 4. 标签统计规则

### 4.1 通用指标
- **标签覆盖数**：统计某个标签关联的笔记数量。
- **未打标笔记数**：在指定 `TagSetId` 下未关联任何标签的笔记数量。
- **批量操作反馈**：返回成功/失败数量与失败明细。

### 4.2 统计维度
- **按标签聚合**：`count(distinct "NoteId")`，支持按报告、品牌、博主等进行二级分组。
- **按笔记聚合**：输出笔记拥有的标签列表以及标签数量，供排序或筛选。
- **时间维度**：按照笔记 `CreatedAt` 的周/月进行聚合，默认只对近 90 天数据统计。

### 4.3 系统标签系列指标
- 系统系列用于全局分析，统计结果允许包含所有用户的笔记（受数据权限控制）。
- 需要额外统计：
  - **标签热度 Top N**：近 30 天按笔记数排序的前 10 个标签。
  - **标签应用率**：`标签覆盖数 / 可访问笔记总数`。

### 4.4 自定义标签系列指标
- 限制在当前用户数据域内。
- 补充指标：
  - **最近更新时间**：`max("UpdatedAt")`。
  - **操作用户**：记录最近一次变更 `UserId` 对应的邮件地址（通过 `auth.users` 查询）。

## 5. 数据去重规则

### 5.1 笔记级去重
- 笔记数据源可能包含重复采集；统一使用 `notes."id"` 作为唯一标识。
- 若同一笔记被重复采集，`INSERT ... ON CONFLICT` 覆盖笔记基础信息，但保留已有标签关联。

### 5.2 标签级去重
- 标签名称在同一标签系列内强制唯一（不区分大小写），通过 `uq_tag_name_per_set` 索引实现。
- 批量写入时使用 `INSERT ... ON CONFLICT DO NOTHING` 避免重复。

### 5.3 关联级去重
- 笔记与标签的多对多关联以组合主键 `("NoteId", "TagId")` 控制唯一性。
- 批量打标使用 `ON CONFLICT DO UPDATE`，确保重复打标仅更新 `UpdatedAt` 与 `UserId`。

## 6. 边界与异常处理
- 标签系列被删除时：
  - 自动清理对应标签及关联。
  - 统计接口在找不到 `TagSetId` 时返回错误码 `TAG_SET_NOT_FOUND`。
- 标签被删除时：
  - 清理关联后，统计接口重新计算。
- 笔记被删除或隐藏时：
  - 删除对应关联记录；统计结果不应包含这些笔记。
- 批量操作限制：
  - 单次最多 500 条笔记；
  - 超限返回 `LIMIT_EXCEEDED`。

## 7. 审计与日志
- 所有增删改操作写入 `qiangua_note_tag."UserId"` 与 `UpdatedAt`。
- 需要在 API 层记录：
  - 操作者 Supabase UID；
  - 请求参数快照；
  - 失败明细列表（存储在 `logs.note_tagging_failed` 表或 Supabase Logflare）。
- 统计接口在 Edge Function 运行时输出 Prometheus 指标：请求次数、平均耗时、错误率。

## 8. 与其它模块的关系
- 与报告模块共享 `notes` 数据源；确保筛选条件保持一致，避免漏数。
- 与品牌/博主管理模块存在外键依赖，删除品牌或博主时需要触发级联清理或软删除策略。
- 与权限系统：沿用 Supabase RLS；服务端（`service_role`）可跨用户执行管理任务。

## 9. TODO
- [ ] 确认 `notes` 表字段是否满足标签统计所需维度（品牌、博主、所属报告等）。
- [ ] 评估 Edge Function 或 SQL Materialized View 的性能开销。
- [ ] 与数据团队同步统计指标的展示频率与存储周期。

## 10. 数据库实现脚本

### 10.1 `scripts/note-tagging-schema.sql`
```sql
-- Supabase schema 默认 public
create extension if not exists "pgcrypto";

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new."UpdatedAt" := now();
  return new;
end;
$$ language plpgsql;

create or replace function public.normalize_tag_set_name()
returns trigger as $$
begin
  new."TagSetName" := nullif(btrim(new."TagSetName"), '');
  return new;
end;
$$ language plpgsql;

create or replace function public.normalize_tag_name()
returns trigger as $$
begin
  new."TagName" := nullif(btrim(new."TagName"), '');
  return new;
end;
$$ language plpgsql;

create table public.qiangua_tag_set (
  "TagSetId" uuid not null default gen_random_uuid(),
  "TagSetName" text not null,
  "Description" text null,
  type text not null default 'custom'::text,
  "UserId" uuid null,
  "CreatedAt" timestamp with time zone not null default now(),
  "UpdatedAt" timestamp with time zone not null default now(),
  constraint qiangua_tag_set_pkey primary key ("TagSetId"),
  constraint chk_tag_set_name_length check (
    char_length(btrim("TagSetName")) >= 4
    and char_length(btrim("TagSetName")) <= 20
  ),
  constraint chk_tag_set_owner_scope check (
    (type = 'system'::text and "UserId" is null)
    or (type = 'custom'::text and "UserId" is not null)
  ),
  constraint chk_tag_set_type check (
    type = any (array['system'::text, 'custom'::text])
  )
);

create table public.qiangua_tag (
  "TagId" uuid not null default gen_random_uuid(),
  "TagSetId" uuid not null,
  "TagName" text not null,
  "UserId" uuid null,
  "CreatedAt" timestamp with time zone not null default now(),
  "UpdatedAt" timestamp with time zone not null default now(),
  constraint qiangua_tag_pkey primary key ("TagId"),
  constraint qiangua_tag_TagSetId_fkey foreign key ("TagSetId") references public.qiangua_tag_set ("TagSetId") on delete cascade,
  constraint chk_tag_name_length check (
    char_length(btrim("TagName")) >= 4
    and char_length(btrim("TagName")) <= 20
  )
);

create table public.qiangua_note_tag (
  "NoteId" character varying not null,
  "TagId" uuid not null,
  "UserId" uuid not null,
  "CreatedAt" timestamp with time zone not null default now(),
  "UpdatedAt" timestamp with time zone not null default now(),
  constraint pk_qiangua_note_tag primary key ("NoteId", "TagId"),
  constraint qiangua_note_tag_NoteId_fkey foreign key ("NoteId") references public.qiangua_note_info ("NoteId") on delete cascade,
  constraint qiangua_note_tag_TagId_fkey foreign key ("TagId") references public.qiangua_tag ("TagId") on delete cascade
);

create unique index if not exists uq_tag_set_system_name
  on public.qiangua_tag_set using btree (lower("TagSetName"))
  where type = 'system'::text
  tablespace pg_default;

create unique index if not exists uq_tag_set_user_name
  on public.qiangua_tag_set using btree ("UserId", lower("TagSetName"))
  where type = 'custom'::text
  tablespace pg_default;

create unique index if not exists uq_tag_name_per_set
  on public.qiangua_tag using btree ("TagSetId", lower("TagName"))
  tablespace pg_default;

create index if not exists idx_tag_by_user
  on public.qiangua_tag using btree ("UserId")
  tablespace pg_default;

create index if not exists idx_note_tag_tagid
  on public.qiangua_note_tag using btree ("TagId")
  tablespace pg_default;

create index if not exists idx_note_tag_user
  on public.qiangua_note_tag using btree ("UserId")
  tablespace pg_default;

create trigger trg_normalize_tag_set_name
before insert or update on public.qiangua_tag_set
for each row
execute function public.normalize_tag_set_name();

create trigger trg_normalize_tag_name
before insert or update on public.qiangua_tag
for each row
execute function public.normalize_tag_name();

create trigger trg_set_qiangua_tag_set_updated_at
before update on public.qiangua_tag_set
for each row
execute function public.set_updated_at();

create trigger trg_set_qiangua_tag_updated_at
before update on public.qiangua_tag
for each row
execute function public.set_updated_at();

create trigger trg_set_qiangua_note_tag_updated_at
before update on public.qiangua_note_tag
for each row
execute function public.set_updated_at();
```

### 10.2 行级安全（RLS）策略
```sql
alter table public.qiangua_tag_set enable row level security;

create policy "Tag sets readable by owner or system"
  on public.qiangua_tag_set
  for select
  using (
    auth.role() = 'service_role'
    or type = 'system'
    or "UserId" = auth.uid()
  );

create policy "Custom tag sets manageable by owner"
  on public.qiangua_tag_set
  for all
  using (
    auth.role() = 'service_role'
    or (type = 'custom' and "UserId" = auth.uid())
  )
  with check (
    auth.role() = 'service_role'
    or (type = 'custom' and "UserId" = auth.uid())
  );

alter table public.qiangua_tag enable row level security;

create policy "Tags readable via accessible tag sets"
  on public.qiangua_tag
  for select
  using (
    auth.role() = 'service_role'
    or exists (
      select 1
      from public.qiangua_tag_set s
      where s."TagSetId" = public.qiangua_tag."TagSetId"
        and (
          s.type = 'system'
          or s."UserId" = auth.uid()
        )
    )
  );

create policy "Custom tags manageable by owner"
  on public.qiangua_tag
  for all
  using (
    auth.role() = 'service_role'
    or exists (
      select 1
      from public.qiangua_tag_set s
      where s."TagSetId" = public.qiangua_tag."TagSetId"
        and s.type = 'custom'
        and s."UserId" = auth.uid()
    )
  )
  with check (
    auth.role() = 'service_role'
    or exists (
      select 1
      from public.qiangua_tag_set s
      where s."TagSetId" = public.qiangua_tag."TagSetId"
        and s.type = 'custom'
        and s."UserId" = auth.uid()
    )
  );

alter table public.qiangua_note_tag enable row level security;

create policy "Note tags readable by owner"
  on public.qiangua_note_tag
  for select
  using (
    auth.role() = 'service_role'
    or "UserId" = auth.uid()
  );

create policy "Note tags writable by owner"
  on public.qiangua_note_tag
  for all
  using (
    auth.role() = 'service_role'
    or "UserId" = auth.uid()
  )
  with check (
    auth.role() = 'service_role'
    or "UserId" = auth.uid()
  );
```

### 10.3 `scripts/note-tagging-init.sql`
```sql
begin;

insert into public.qiangua_tag_set ("TagSetId", "TagSetName", type, "UserId")
values
  ('00000000-0000-0000-0000-000000000001', '内容场景', 'system', null)
on conflict ("TagSetId") do nothing;

insert into public.qiangua_tag ("TagId", "TagSetId", "TagName", "UserId")
values
  ('00000000-0000-0000-0000-00000000c001', '00000000-0000-0000-0000-000000000001', '品牌品宣', null),
  ('00000000-0000-0000-0000-00000000c002', '00000000-0000-0000-0000-000000000001', '明星代言', null),
  ('00000000-0000-0000-0000-00000000c003', '00000000-0000-0000-0000-000000000001', '穿搭叙事', null),
  ('00000000-0000-0000-0000-00000000c004', '00000000-0000-0000-0000-000000000001', '明星同款私服', null),
  ('00000000-0000-0000-0000-00000000c005', '00000000-0000-0000-0000-000000000001', '创意手绘视频', null),
  ('00000000-0000-0000-0000-00000000c006', '00000000-0000-0000-0000-000000000001', '创意舞蹈视频', null)
on conflict ("TagId") do nothing;

commit;
```

